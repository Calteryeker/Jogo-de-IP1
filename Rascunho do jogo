#include <stdio.h>
#include <stdlib.h>
#include <SDL.h>

// Função que inicialia APENAS as funções de video do SDL
bool init_video()
{
	bool sucess = true; // Variável que será retornada. Continuará true se nada der errado

	if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
	{
		printf("Erro de inicialização! > SDL_INIT_VIDEO <  SDL error: %s\n", SDL_GetError() );
		sucess = false;
	}

	return sucess;
}


// Função que carrega e otimiza um bitmap em variáveis do tipo SDL_surface
SDL_Surface* load_surface(const char* path_do_arquivo, SDL_Surface* surface_principal)
{
	SDL_Surface* OptimizedSurface = NULL;

	SDL_Surface* LoadedSurface = SDL_LoadBMP(path_do_arquivo); // Load surface

	if (LoadedSurface == NULL) // Se NULL, então não ocorreu o load surface
	{
		printf("Erro ao carregar a imagem! \n Imagem: %s \n	SDL_GetError: %s", path_do_arquivo, SDL_GetError());
	}
	else
	{
		// Convert surface to screen format
		 OptimizedSurface = SDL_ConvertSurface(LoadedSurface, surface_principal->format, 0); // Converte a surface de 24bit para 32bit

		 if (OptimizedSurface == NULL) // Se NULL, então não ocorreu o convert surface
		 {
			 printf("Erro ao otimizar imagem! zn Imagem: %s \n SDL_GetError: %s", path_do_arquivo, SDL_GetError());
		 }
		 
		 SDL_FreeSurface(LoadedSurface); // Libera da memória a LoadedSurface
	}

	return LoadedSurface;
}


int main(int argc, char* argv[])
{
	// y62Kqx <- Alguma informação do professor que eu ñ lembro o que era

	// Inicializa o SDL_VIDEO (Permite utilizar funções de imagem)
	init_video();
	

	// =-= =-= =-= =-= =-=   Variáveis   =-= =-= =-= =-= //

	int JANELA_WIDTH = 800;  // 1536 | 1920
	int JANELA_HEIGHT = 600; // 864 | 1080

	// Criação da janela(windown) principal
	//                                    Título       Ponto incial x          Ponto inicial y         Largura       Altura              FLAG
	SDL_Window* janela = SDL_CreateWindow("Jogo", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, JANELA_WIDTH, JANELA_HEIGHT, SDL_WINDOW_SHOWN);
	SDL_Surface* Interface_Principal = SDL_GetWindowSurface(janela);


	bool game_loop = true; // Variável que so fica falsa quando um evento finalizar o jogo
	int sprite = 1; // Variável do número do sprite(desenho) do detetive que vai ser mostrado

	SDL_Event event; // Variável que vai conter os eventos(inputs) do usuário

	enum Key_Press
	{
		KEY_PRESS_DEFAULT, // 0
		KEY_PRESS_UP,      // 1
		KEY_PRESS_LEFT,    // 2
		KEY_PRESSS_DOWN,   // 3
		KEY_PRESS_RIGHT,   // 4
		KEY_PRESS_TOTAL    // 5
	};

	SDL_Surface* Interface_BackGround = SDL_LoadBMP("Imagens/background.bmp"); // Variável que contem a imagem do fundo (background)
	//SDL_Surface* Interface_BackGround = load_surface("Imagens/background.bmp", Interface_Principal); // Variável que contem a imagem do fundo (background)

	SDL_Surface* Interface_Detetive = NULL; // Variável do tipo SDL_Surface pointer que contem o sprite do detetive
	
	// =-= Retângulos das interfaces =-= //

	SDL_Rect rect_principal; // Retângulo da interface principal
	rect_principal.x = 0;
	rect_principal.y = 0;
	rect_principal.w = JANELA_WIDTH;
	rect_principal.h = JANELA_HEIGHT;

	SDL_Rect rect_detetive;
	rect_detetive.x = (JANELA_WIDTH / 2  -  96 / 2);
	rect_detetive.y = (JANELA_HEIGHT / 2  -  96 / 2);
	rect_detetive.w = 96;
	rect_detetive.h = 96;

	// =-= Fim dos retângulos =-= //


	// =-= =-= =-= =-= =-=   Fim das Variáveis   =-= =-= =-= =-= //

	// Preenchimento do background
	SDL_BlitScaled(Interface_BackGround, NULL, Interface_Principal, &rect_principal);

	// Atualiza e mostra a janela
	SDL_UpdateWindowSurface(janela);
	SDL_ShowWindow(janela);

	// Loop principal do jogo (Importante: apenas no inicio ele atualiza a janela)
	while (game_loop)
	{
		SDL_UpdateWindowSurface(janela);

		// Loop que trata os eventos
		while (SDL_PollEvent( &event ) != 0) // enquanto existir evento o loop continua
		{
			// Evento: fechar janela
			if ( event.type == SDL_QUIT )
			{
				game_loop = false;
			}
			// Evento: Pressionar uma tecla qualquer no teclado
			else if ( event.type == SDL_KEYDOWN )
			{
				//Switch das teclas que fazem algo ao serem pressionadas
				switch (event.key.keysym.sym)
				{
				case SDLK_w:
					// switch dos sprites (OBSERVAÇÃO: do jeito q ta tem 2 problemas)
					// 1- A variável sprite não reseta pra 1 quando muda de direção
					// 2- O movimento tera que ser sincronizado em 2 ou 4 tempos, ou seja, 1 passo no jogo tem q ter 2 ou 4 frames
					// Já que existe esses problemas, eu resolvi colocar apenas esse switch de teste para a tecla w (1 das 4 direções)
					switch (sprite)
					{
					case 1:
						Interface_Detetive = SDL_LoadBMP("Imagens/detetive costa 1.bmp");

						sprite += 1;
						break;

					case 2:
						Interface_Detetive = SDL_LoadBMP("Imagens/detetive costa 2.bmp");

						sprite += 1;
						break;
					case 3:
						Interface_Detetive = SDL_LoadBMP("Imagens/detetive costa 3.bmp");

						sprite += 1;
						break;
					case 4:
						Interface_Detetive = SDL_LoadBMP("Imagens/detetive costa 4.bmp");

						sprite = 1;
						break;
					}
					break;

				case SDLK_a:
					Interface_Detetive = SDL_LoadBMP("Imagens/detetive lado direito 1.bmp");

					break;

				case SDLK_s:
					Interface_Detetive = SDL_LoadBMP("Imagens/detetive frente 1.bmp");

					break;

				case SDLK_d:
					Interface_Detetive = SDL_LoadBMP("Imagens/detetive lado direito 1.bmp"); // Está imagem ainda não está invertida

					break;

				case SDLK_ESCAPE:
					// Códico que faz aparecer menu ao apertar ESC
					game_loop = false;

					break;

				}// Fim do switch das teclas
				
			}// Fim dos evento de teclado

		}// Fim do loop de tratamento de eventos


		SDL_BlitScaled(Interface_Detetive, NULL, Interface_Principal, &rect_detetive); // Coloca a imagem do detetive na janela
	

	} // Fim do while(game_loop)


	// Finalização do SDL
	SDL_DestroyWindow(janela); // Tira a janela da MEM
	SDL_Quit(); // Fecha o SDL	


	return 0;
} // Fim do Main


